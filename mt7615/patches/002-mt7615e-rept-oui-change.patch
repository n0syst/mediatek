From e9bf40b8bc6ccc0e2e4b53dcf3bf51d65ac6bf00 Mon Sep 17 00:00:00 2001
From: Anjan Chanda <anjan.chanda@iopsys.eu>
Date: Fri, 19 Jun 2020 14:55:23 +0200
Subject: [PATCH] tmp2

---
 mt_wifi/embedded/ap/ap_cfg.c            |   7 +
 mt_wifi/embedded/ap/ap_repeater.c       |  33 +-
 mt_wifi/embedded/ap/iopsys_ioctl.c      | 528 ++++++++++++++++++++++++++++++++
 mt_wifi/embedded/include/iopsys_ioctl.h | 204 ++++++++++++
 mt_wifi/embedded/include/rt_config.h    |   5 +
 mt_wifi_ap/Makefile                     |   6 +
 6 files changed, 781 insertions(+), 2 deletions(-)
 create mode 100644 mt_wifi/embedded/ap/iopsys_ioctl.c
 create mode 100644 mt_wifi/embedded/include/iopsys_ioctl.h

diff --git a/mt_wifi/embedded/ap/ap_cfg.c b/mt_wifi/embedded/ap/ap_cfg.c
index 4bcc593..06ff0d6 100644
--- a/mt_wifi/embedded/ap/ap_cfg.c
+++ b/mt_wifi/embedded/ap/ap_cfg.c
@@ -16166,6 +16166,13 @@ INT RTMP_AP_IoctlHandle(
 #endif /* HOSTAPD_11R_SUPPORT */
 
 	case CMD_RT_PRIV_IOCTL:
+			/* iopsys ioctl entry point */
+			if ((INT)(subcmd & 0x7fff) >= OID_IOPSYS_WIFI_FIRST
+					&& (INT)(subcmd & 0x7fff) <= OID_IOPSYS_WIFI_LAST) {
+				Status = mt_ioctl_iopsys(pAd, wrq, (INT)subcmd);
+				break;
+			}
+
 		if (subcmd & OID_GET_SET_TOGGLE)
 			Status = RTMPAPSetInformation(pAd, wrq,  (INT)subcmd);
 		else {
diff --git a/mt_wifi/embedded/ap/ap_repeater.c b/mt_wifi/embedded/ap/ap_repeater.c
index eb24afd..f795cef 100644
--- a/mt_wifi/embedded/ap/ap_repeater.c
+++ b/mt_wifi/embedded/ap/ap_repeater.c
@@ -754,6 +754,7 @@ VOID RTMPInsertRepeaterEntry(
 	INT pValid_ReptCliIdx;
 	PREPEATER_CLIENT_ENTRY_MAP pReptCliMap;
 	RTMP_CHIP_CAP *cap = hc_get_chip_cap(pAd->hdev_ctrl);
+	BOOLEAN realmac = TRUE;
 
 	MTWF_LOG(DBG_CAT_CLIENT, CATCLIENT_APCLI, DBG_LVL_TRACE,
 			 ("%s.\n", __func__));
@@ -891,10 +892,38 @@ VOID RTMPInsertRepeaterEntry(
 			}
 		}
 		NdisCopyMemory(tempMAC, VENDOR_DEFINED_OUI_ADDR[IdxToUse], OUI_LEN);
-	} else
+	}
+	else
+	{
+#ifdef MAC_REPEATER_OUI_CHANGE
 		NdisCopyMemory(tempMAC, wdev->if_addr, OUI_LEN);
+#else
+		MAC_TABLE_ENTRY *pMacEntry = NULL;
+
+		/* passthrough eth-Client's mac transparently*/
+		pMacEntry = MacTableLookup(pAd, pAddr);
+                if (pMacEntry && IS_ENTRY_CLIENT(pMacEntry)) {
+			struct wifi_dev *wd = &pAd->ApCfg.MBSSID[0].wdev;
+
+			tempMAC[0] = wdev->if_addr[0];
+
+			if (wd && wd->FtCfg.FtMdId) {
+				tempMAC[1] = wd->FtCfg.FtMdId[0];
+				tempMAC[2] = wd->FtCfg.FtMdId[1];
+			} else {
+				tempMAC[1] = 0x01;
+				tempMAC[2] = 0xf4;
+			}
+			printk("%s(): Clone WiFi-rept client's mac!\n", __func__);
+			realmac = FALSE;
+		}
+		else
+			printk("%s(): Pass Eth-rept client's mac unchanged\n", __func__);
+
+#endif /* MAC_REPEATER_OUI_CHANGE */
+	}
 
-	if (RTMPLookupRepeaterCliEntry_NoLock(pAd, FALSE, tempMAC, TRUE) != NULL) {
+	if (RTMPLookupRepeaterCliEntry_NoLock(pAd, realmac, tempMAC, TRUE) != NULL) {
 		NdisReleaseSpinLock(&pAd->ApCfg.ReptCliEntryLock);
 		MTWF_LOG(DBG_CAT_CLIENT, CATCLIENT_APCLI, DBG_LVL_ERROR,
 				("ReptCLI duplicate Insert %02x:%02x:%02x:%02x:%02x:%02x !\n",
diff --git a/mt_wifi/embedded/ap/iopsys_ioctl.c b/mt_wifi/embedded/ap/iopsys_ioctl.c
new file mode 100644
index 0000000..f4c9996
--- /dev/null
+++ b/mt_wifi/embedded/ap/iopsys_ioctl.c
@@ -0,0 +1,528 @@
+/* File: iopsys_ioctl.c
+ *
+ * Author: Anjan Chanda <anjan.chanda@inteno.se>
+ *
+ */
+#include "rt_config.h"
+#include "rtmp.h"
+
+#ifndef MBCAST_WCID
+#define MBCAST_WCID  127
+#endif
+
+
+static void mt_parse_rate(RTMP_ADAPTER *pAd, u8 rx, u32 rate_data,
+							struct wifi_sta *sta)
+{
+	extern UCHAR tmi_rate_map_ofdm[];
+	extern UCHAR tmi_rate_map_cck_lp[];
+	extern UCHAR tmi_rate_map_cck_sp[];
+	u8 phy_mode, mcs, bw, preamble, sgi;
+	u8 vht_nss = 0;
+	struct wifi_rate *rate = rx ? &sta->rx : &sta->tx;
+
+	phy_mode = (rate_data >> 13) & 0x7;
+	mcs = rate_data & 0x3F;
+	bw = (rate_data >> 7) & 0x3;
+	sgi = (rate_data >> 9) & 0x1;
+
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED))
+		preamble = SHORT_PREAMBLE;
+	else
+		preamble = LONG_PREAMBLE;
+
+	if ( phy_mode == MODE_CCK && !rx) {
+		mcs = (preamble == LONG_PREAMBLE) ?
+			tmi_rate_map_cck_lp[mcs] : tmi_rate_map_cck_sp[mcs];
+	} else if ( phy_mode == MODE_OFDM && !rx) {
+		mcs = tmi_rate_map_ofdm[mcs];
+	} else if ( phy_mode == MODE_VHT ) {
+		vht_nss = ((mcs & (0x3 << 4)) >> 4) + 1;
+		mcs = mcs & 0xF;
+	}
+
+	rate->mcs = mcs;
+	rate->nss = (vht_nss == 0)? 1 : vht_nss;	// FIXME: non-vht
+	rate->bw = bw;
+	rate->sgi = sgi ? 1 : 0;
+
+	MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+		("    Last %s :::: Phy = %d BW = %d SGI = %d MCS = %d (ratedata = 0x%x)\n",
+		rx ? "Rx" : "Tx", phy_mode, rate->bw, rate->sgi, rate->mcs, rate_data));
+}
+
+static int mt_ioctl_iopsys_get_stainfo (RTMP_ADAPTER *pAd,
+					RTMP_IOCTL_INPUT_STRUCT *wrq)
+{
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+	int iftype = pObj->ioctl_if_type;
+	u8 apidx = pObj->ioctl_if;
+	struct wifi_sta sta;
+	unsigned long maxrate_mbps = 0, tx_mbps = 0, rx_mbps = 0;
+	int i;
+
+	if (!pAd->MacTab.Size) {
+		wrq->u.data.length = 0;
+		return 0;
+	}
+
+	if (wrq->u.data.length != sizeof(struct wifi_sta)) {
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_WARN,
+			("ioctl buffer size mismatch!\n"));
+		return -E2BIG;
+	}
+
+	memset(&sta, 0, sizeof(struct wifi_sta));
+	if (copy_from_user(&sta, wrq->u.data.pointer, wrq->u.data.length)) {
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_WARN,
+			("%s: copy_from_user failed!\n", __func__));
+		return -EFAULT;
+	}
+
+	//printk("%s(): %d:  MacTab.Size = %d HcGetMaxStaNum = %d [ MacTable Size = %d ]\n",
+	//	__func__, __LINE__, pAd->MacTab.Size, HcGetMaxStaNum(pAd), MAX_LEN_OF_MAC_TABLE);
+
+	for (i = 0; i < MAX_LEN_OF_MAC_TABLE; i++) {
+		PMAC_TABLE_ENTRY pEntry = &(pAd->MacTab.Content[i]);
+
+		if (!MAC_ADDR_EQUAL(sta.addr, pEntry->Addr))
+			continue;
+
+		if ((iftype == INT_MBSSID || iftype == INT_MAIN)
+				&& IS_ENTRY_CLIENT(pEntry)
+				&& pEntry->Sst==SST_ASSOC
+				&& pEntry->apidx == apidx) {
+
+			UINT32 lastRxRate = pEntry->LastRxRate;
+			UINT32 lastTxRate = pEntry->LastTxRate;
+			//u32 airtime_pcnt = 0;
+			struct _RTMP_CHIP_CAP *chipcap;
+
+			chipcap = hc_get_chip_cap(pAd->hdev_ctrl);
+
+			MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+					("\n[%d] STA: %02X:%02X:%02X:%02X:%02X:%02X\n",
+					i, PRINT_MAC(pEntry->Addr)));
+
+#ifdef RACTRL_FW_OFFLOAD_SUPPORT
+			if (chipcap->fgRateAdaptFWOffload == TRUE
+					&& pEntry->bAutoTxRateSwitch == TRUE) {
+
+				EXT_EVENT_TX_STATISTIC_RESULT_T entry_tx_stat = {0};
+				HTTRANSMIT_SETTING entry_tx_rate;
+
+				MtCmdGetTxStatistic(pAd,
+					GET_TX_STAT_ENTRY_TX_RATE | GET_TX_STAT_TOTAL_TX_CNT,
+					0, pEntry->wcid, &entry_tx_stat);
+
+				entry_tx_rate.field.MODE = entry_tx_stat.rEntryTxRate.MODE;
+				entry_tx_rate.field.BW = entry_tx_stat.rEntryTxRate.BW;
+				entry_tx_rate.field.ldpc = entry_tx_stat.rEntryTxRate.ldpc ? 1:0;
+				entry_tx_rate.field.ShortGI = entry_tx_stat.rEntryTxRate.ShortGI ? 1:0;
+				entry_tx_rate.field.STBC = entry_tx_stat.rEntryTxRate.STBC;
+				if (entry_tx_rate.field.MODE == MODE_VHT) {
+					entry_tx_rate.field.MCS = (((entry_tx_stat.rEntryTxRate.VhtNss - 1) & 0x3) << 4) +
+								entry_tx_stat.rEntryTxRate.MCS;
+				}
+				else {
+					entry_tx_rate.field.MCS = entry_tx_stat.rEntryTxRate.MCS;
+				}
+
+				MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+					("    PHYS_CAPS:::: Entry[%d] : Mode = %d BW = %d SGI = %d MCS = %d\n",
+					i, entry_tx_rate.field.MODE, entry_tx_rate.field.BW,
+					entry_tx_rate.field.ShortGI, entry_tx_rate.field.MCS));
+
+
+				lastTxRate = (UINT32)(entry_tx_rate.word);
+			}
+#endif /* RACTRL_FW_OFFLOAD_SUPPORT */
+
+			mt_parse_rate(pAd, 0, lastTxRate, &sta);
+			mt_parse_rate(pAd, 1, lastRxRate, &sta);
+
+			getRate((HTTRANSMIT_SETTING)((USHORT)lastTxRate), &tx_mbps);
+			getRate((HTTRANSMIT_SETTING)((USHORT)lastRxRate), &rx_mbps);
+			sta.tx_rate = tx_mbps;
+			sta.rx_rate = rx_mbps;
+			MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+				("    Current Rate:: Tx = %d Mbps,  Rx = %d Mbps\n",
+				sta.tx_rate, sta.rx_rate));
+
+			sta.rssi[0] = pEntry->RssiSample.LastRssi[0] - pAd->BbpRssiToDbmDelta;
+			sta.rssi[1] = pEntry->RssiSample.LastRssi[1] - pAd->BbpRssiToDbmDelta;
+			sta.rssi[2] = pEntry->RssiSample.LastRssi[2] - pAd->BbpRssiToDbmDelta;
+			sta.rssi[3] = pEntry->RssiSample.LastRssi[3] - pAd->BbpRssiToDbmDelta;
+
+			MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+				("    RSSI            = %d %d %d %d\n",
+					sta.rssi[0],
+					sta.rssi[1],
+					sta.rssi[2],
+					sta.rssi[3]));
+
+			sta.stats.tx_pkts = pEntry->TxPackets.QuadPart;
+			sta.stats.tx_bytes = pEntry->TxBytes;
+
+			MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+				("    Tx Pakets       = %-10u     Tx Bytes         = %llu\n",
+					sta.stats.tx_pkts,
+					sta.stats.tx_bytes));
+
+			sta.stats.rx_pkts = pEntry->RxPackets.QuadPart;
+			sta.stats.rx_bytes = pEntry->RxBytes;
+
+			MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+				("    Rx Pakets       = %-10u     Rx Bytes         = %llu\n",
+					sta.stats.rx_pkts,
+					sta.stats.rx_bytes));
+
+			sta.connected_ms = (int)(pEntry->StaConnectTime);
+			sta.idle_ms = (int)(pEntry->NoDataIdleCount);
+
+			/* capabilities */
+			sta.caps = 0;
+			if (CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_WMM_CAPABLE))
+				sta.caps |= STA_CAP_WME;
+
+			if (CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_HT_CAPABLE))
+				sta.caps |= STA_CAP_HT;
+
+			if (CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_VHT_CAPABLE))
+				sta.caps |= STA_CAP_VHT;
+
+			if (CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_APSD_CAPABLE))
+				sta.caps |= STA_CAP_PS;
+
+			if (CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_AMSDU_INUSED))
+				sta.caps |= STA_CAP_AMSDU;
+
+			if (CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_SGI20_CAPABLE
+						| fCLIENT_STATUS_SGI40_CAPABLE
+						| fCLIENT_STATUS_SGI80_CAPABLE
+						| fCLIENT_STATUS_SGI160_CAPABLE))
+				sta.caps |= STA_CAP_SGI;
+
+			if (CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_TxSTBC_CAPABLE
+						| fCLIENT_STATUS_RxSTBC_CAPABLE
+						| fCLIENT_STATUS_VHT_TXSTBC_CAPABLE
+						| fCLIENT_STATUS_VHT_RXSTBC_CAPABLE))
+				sta.caps |= STA_CAP_STBC;
+
+			if (CLIENT_STATUS_TEST_FLAG(pEntry,
+					fCLIENT_STATUS_VHT_RX_LDPC_CAPABLE
+					| fCLIENT_STATUS_HT_RX_LDPC_CAPABLE))
+
+				sta.caps |= STA_CAP_LDPC;
+
+#ifdef DOT11K_RRM_SUPPORT
+			if (pEntry->RrmEnCap.field.BeaconPassiveMeasureCap == 1)
+				sta.caps |= STA_CAP_11K_BCN_PASV;
+			if (pEntry->RrmEnCap.field.BeaconActiveMeasureCap == 1)
+				sta.caps |= STA_CAP_11K_BCN_ACTV;
+			if (pEntry->RrmEnCap.field.BeaconTabMeasureCap == 1)
+				sta.caps |= STA_CAP_11K_BCN_TBL;
+#endif
+
+#ifdef CONFIG_DOT11V_WNM
+			if (pEntry->BssTransitionManmtSupport == 1)
+				sta.caps |= STA_CAP_11V_BSS_TRANS;
+#endif
+
+			//TODO: maxcaps
+
+			/* printk("    Avg RSSI: %-7d%-7d%-7d%-7d",
+					pEntry->RssiSample.AvgRssi[0],
+					pEntry->RssiSample.AvgRssi[1],
+					pEntry->RssiSample.AvgRssi[2],
+					pEntry->RssiSample.AvgRssi[3]);
+			*/
+			getRate(pEntry->MaxHTPhyMode, &maxrate_mbps);
+			sta.maxrate = maxrate_mbps;
+
+			MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+				("    HTPhyMode: MaxRate = (%d Mbps) Mode = %d BW = %d SGI = %d MCS = %d\n",
+					sta.maxrate,
+					pEntry->MaxHTPhyMode.field.MODE,
+					pEntry->MaxHTPhyMode.field.BW,
+					pEntry->MaxHTPhyMode.field.ShortGI ? 1 : 0,
+					pEntry->MaxHTPhyMode.field.MCS));
+
+
+			MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+					("    Avg SNR:::: %d  %d  %d  %d\n",
+					pEntry->RssiSample.AvgSnr[0],
+					pEntry->RssiSample.AvgSnr[1],
+					pEntry->RssiSample.AvgSnr[2],
+					pEntry->RssiSample.AvgSnr[3]));
+		}
+	}
+
+	wrq->u.data.length = sizeof(struct wifi_sta);
+	if (copy_to_user(wrq->u.data.pointer, &sta, wrq->u.data.length)) {
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_WARN,
+			("%s: copy_to_user() fail\n", __func__));
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int mt_ioctl_iopsys_get_bssinfo (RTMP_ADAPTER *pAd,
+					RTMP_IOCTL_INPUT_STRUCT *wrq)
+{
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+	struct _SECURITY_CONFIG *sec = NULL;
+	u8 apidx = pObj->ioctl_if;
+	struct wifi_dev *wdev;
+	struct wifi_bss bss;
+	int ssidlen;
+
+	if (apidx >= HW_BEACON_MAX_NUM)
+		return -1;
+
+	memset(&bss, 0, sizeof(struct wifi_bss));
+	wdev = &pAd->ApCfg.MBSSID[apidx].wdev;
+	bss.channel = wdev->channel;
+
+	ssidlen = pAd->ApCfg.MBSSID[apidx].SsidLen;
+	snprintf(bss.ssid, ssidlen + 1, "%s", (char *)pAd->ApCfg.MBSSID[apidx].Ssid);
+
+	snprintf(bss.bssid, 18, "%02x:%02x:%02x:%02x:%02x:%02x",
+		pAd->ApCfg.MBSSID[apidx].wdev.bssid[0],
+		pAd->ApCfg.MBSSID[apidx].wdev.bssid[1],
+		pAd->ApCfg.MBSSID[apidx].wdev.bssid[2],
+		pAd->ApCfg.MBSSID[apidx].wdev.bssid[3],
+		pAd->ApCfg.MBSSID[apidx].wdev.bssid[4],
+		pAd->ApCfg.MBSSID[apidx].wdev.bssid[5]);
+
+	sec = &pAd->ApCfg.MBSSID[apidx].wdev.SecConfig;
+	bss.encryption = GET_SEC_AKM(sec);
+	bss.cipher = GET_PAIRWISE_CIPHER(sec);
+
+	bss.rssi = pAd->ApCfg.RssiSample.LastRssi[0] - pAd->BbpRssiToDbmDelta;
+	// rssi[1]..rssi[3] ?
+
+	bss.load.sta_count = pAd->ApCfg.MBSSID[apidx].StaCount;
+	bss.load.utilization =  (pAd->OneSecMibBucket.MyTxAirtime[0] +
+				pAd->OneSecMibBucket.MyRxAirtime[0]) * 1024 / 10000000L;
+
+	MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+		("Sta Cnt = %d    BSS utilization = %d\n",
+		 bss.load.sta_count, bss.load.utilization));
+	MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+		("Bss Tx airtime = %d\n", pAd->OneSecMibBucket.MyTxAirtime[0]));
+	MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+		("Bss Rx airtime = %d\n", pAd->OneSecMibBucket.MyRxAirtime[0]));
+
+	wrq->u.data.length = sizeof(struct wifi_bss);
+	if (copy_to_user(wrq->u.data.pointer, &bss, wrq->u.data.length)) {
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+			("%s: copy_to_user() fail\n", __func__));
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int mt_ioctl_iopsys_get_bss_stats (RTMP_ADAPTER *pAd,
+					RTMP_IOCTL_INPUT_STRUCT *wrq)
+{
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+	u8 apidx = pObj->ioctl_if;
+	struct wifi_ap_stats ap;
+
+	if (apidx >= HW_BEACON_MAX_NUM)
+		return -1;
+
+	memset(&ap, 0, sizeof(struct wifi_ap_stats));
+
+	ap.rx_bytes = pAd->ApCfg.MBSSID[apidx].ReceivedByteCount;
+	ap.tx_bytes = pAd->ApCfg.MBSSID[apidx].TransmittedByteCount;
+
+	ap.rx_pkts = pAd->ApCfg.MBSSID[apidx].RxCount;
+	ap.tx_pkts = pAd->ApCfg.MBSSID[apidx].TxCount;
+
+	ap.rx_dropped_pkts = pAd->ApCfg.MBSSID[apidx].RxDropCount;
+	ap.tx_dropped_pkts = pAd->ApCfg.MBSSID[apidx].TxDropCount;
+
+	ap.rx_err_pkts = pAd->ApCfg.MBSSID[apidx].RxErrorCount;
+	ap.tx_err_pkts = pAd->ApCfg.MBSSID[apidx].TxErrorCount;
+
+	if (copy_to_user(wrq->u.data.pointer, &ap, wrq->u.data.length)) {
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+			("%s: copy_to_user() fail\n", __func__));
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int mt_ioctl_iopsys_get_scanresults(RTMP_ADAPTER *pAd,
+					RTMP_IOCTL_INPUT_STRUCT *wrq)
+{
+	struct wifi_bss *bsss, *entry;
+	int i, waitcnt = 0;
+	int bsss_len = 0;
+	BSS_ENTRY *pBss;
+	int wmode;
+
+	if (pAd->ScanTab.BssNr == 0) {
+		wrq->u.data.length = 0;
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+				("No scan results!\n"));
+		return 0;
+	}
+
+	bsss_len = pAd->ScanTab.BssNr * sizeof(struct wifi_bss);
+	if (wrq->u.data.length < bsss_len) {
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_WARN,
+				("ioctl inadequate buffer size! need = %d bytes\n",
+				bsss_len));
+		return -E2BIG;
+	}
+
+	os_alloc_mem(NULL, (PUCHAR *)&bsss, bsss_len);
+	if (bsss == NULL) {
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_WARN,
+				("memory alloc fail!\n"));
+		return -1;
+	}
+	memset(bsss, 0 , bsss_len);
+	while ((ScanRunning(pAd) == TRUE) && (waitcnt++ < 200))
+		OS_WAIT(500);
+
+	for (i = 0; i < pAd->ScanTab.BssNr; i++) {
+		pBss = &pAd->ScanTab.BssEntry[i];
+		if (pBss->Channel == 0)
+			break;
+
+		entry = bsss + i;
+		entry->channel = pBss->Channel;
+		entry->frequency = pBss->Channel > 14 ? 5 : 2;
+		if (RTMPCheckStrPrintAble((PCHAR)pBss->Ssid, pBss->SsidLen)) {
+			NdisMoveMemory(entry->ssid, pBss->Ssid, pBss->SsidLen);
+		} else {
+			int idx = 0;
+
+			sprintf(entry->ssid, "0x");
+			for (idx = 0; (idx < 14) && (idx < pBss->SsidLen); idx++)
+				sprintf(entry->ssid + 2 + (idx * 2),
+						"%02X", (UCHAR)pBss->Ssid[idx]);
+		}
+
+		sprintf(entry->bssid, "%02x:%02x:%02x:%02x:%02x:%02x",
+				pBss->Bssid[0], pBss->Bssid[1], pBss->Bssid[2],
+				pBss->Bssid[3], pBss->Bssid[4], pBss->Bssid[5]);
+
+		if (IS_AKM_OPEN(pBss->AKMMap))
+			entry->encryption = AUTH_OPEN;
+		else if (IS_AKM_SHARED(pBss->AKMMap))
+			entry->encryption = AUTH_SHARED;
+		else if (IS_AKM_AUTOSWITCH(pBss->AKMMap))
+			entry->encryption = AUTH_WEPAUTO;
+		else if (IS_AKM_WPANONE(pBss->AKMMap))
+			entry->encryption = AUTH_WPANONE;
+		else if (IS_AKM_WPA1(pBss->AKMMap) && IS_AKM_WPA2(pBss->AKMMap))
+			entry->encryption = AUTH_WPA | AUTH_WPA2;
+		else if (IS_AKM_WPA1PSK(pBss->AKMMap) && IS_AKM_WPA2PSK(pBss->AKMMap))
+			entry->encryption = AUTH_WPAPSK | AUTH_WPA2PSK;
+		else if (IS_AKM_WPA1(pBss->AKMMap))
+			entry->encryption = AUTH_WPA;
+		else if (IS_AKM_WPA1PSK(pBss->AKMMap))
+			entry->encryption = AUTH_WPAPSK;
+		else if (IS_AKM_WPA2(pBss->AKMMap))
+			entry->encryption = AUTH_WPA2;
+		else if (IS_AKM_WPA2PSK(pBss->AKMMap))
+			entry->encryption = AUTH_WPA2PSK;
+		else
+			entry->encryption = AUTH_UNKNOWN;
+
+		if (IS_CIPHER_NONE(pBss->PairwiseCipher))
+			entry->cipher = WIFI_CIPHER_NONE;
+		else if (IS_CIPHER_WEP(pBss->PairwiseCipher))
+			entry->cipher = WIFI_CIPHER_WEP;
+		else if (IS_CIPHER_TKIP(pBss->PairwiseCipher) &&
+				IS_CIPHER_CCMP128(pBss->PairwiseCipher))
+			entry->cipher = WIFI_CIPHER_TKIP | WIFI_CIPHER_AES;
+		else if (IS_CIPHER_TKIP(pBss->PairwiseCipher))
+			entry->cipher = WIFI_CIPHER_TKIP;
+		else if (IS_CIPHER_CCMP128(pBss->PairwiseCipher))
+			entry->cipher = WIFI_CIPHER_AES;
+		else if (IS_CIPHER_CCMP256(pBss->PairwiseCipher))
+			entry->cipher = WIFI_CIPHER_CCMP256;
+		else if (IS_CIPHER_GCMP128(pBss->PairwiseCipher))
+			entry->cipher = WIFI_CIPHER_GCMP128;
+		else if (IS_CIPHER_GCMP256(pBss->PairwiseCipher))
+			entry->cipher = WIFI_CIPHER_GCMP256;
+		else
+			entry->cipher = WIFI_CIPHER_UNKNOWN;
+
+		entry->rssi = (int)pBss->Rssi;
+
+		wmode = NetworkTypeInUseSanity(pBss);
+		if (wmode == Ndis802_11FH || wmode == Ndis802_11DS)
+			entry->mode = MODE_B;
+		else if (wmode == Ndis802_11OFDM5)
+			entry->mode = MODE_A;
+		else if (wmode == Ndis802_11OFDM5_N)
+			entry->mode = MODE_A | MODE_N;
+		else if (wmode == Ndis802_11OFDM5_AC)
+			entry->mode = MODE_A | MODE_N | MODE_AC;
+		else if (wmode == Ndis802_11OFDM24)
+			entry->mode = MODE_B | MODE_G;
+		else if (wmode == Ndis802_11OFDM24_N)
+			entry->mode = MODE_B | MODE_G | MODE_N;
+		else
+			entry->mode = MODE_UNKNOWN;
+
+		if (pBss->QbssLoad.bValid == 1) {
+			entry->load.sta_count = pBss->QbssLoad.StaNum;
+			entry->load.utilization = pBss->QbssLoad.ChannelUtilization;
+			entry->load.available = pBss->QbssLoad.RemainingAdmissionControl;
+		} else {
+			MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+				("Bssload not present at idx = %d\n", i));
+		}
+
+		// TODO capabilities
+	}
+
+	wrq->u.data.length = i * sizeof(struct wifi_bss);
+	if (copy_to_user(wrq->u.data.pointer, bsss, wrq->u.data.length)) {
+		os_free_mem((PUCHAR)bsss);
+		return -EFAULT;
+	}
+
+	MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+			("%s: return len = %d\n", __func__, wrq->u.data.length));
+	os_free_mem((PUCHAR)bsss);
+
+	return 0;
+}
+
+int mt_ioctl_iopsys(IN RTMP_ADAPTER *pAd, OUT RTMP_IOCTL_INPUT_STRUCT *wrq, IN int cmd)
+{
+	int ret = 0;
+
+	switch(cmd & 0x7fff) {
+	case OID_IOPSYS_WIFI_STA_INFO:
+		ret = mt_ioctl_iopsys_get_stainfo(pAd, wrq);
+		break;
+	case OID_IOPSYS_WIFI_BSS_INFO:
+		ret = mt_ioctl_iopsys_get_bssinfo(pAd, wrq);
+		break;
+	case OID_IOPSYS_WIFI_SITESURVEY:
+		ret = mt_ioctl_iopsys_get_scanresults(pAd, wrq);
+		break;
+	case OID_IOPSYS_WIFI_BSS_STATS:
+		ret = mt_ioctl_iopsys_get_bss_stats(pAd, wrq);
+		break;
+	default:
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+			("%s(): Unhandled cmd!\n", __func__));
+		ret = -EFAULT;
+	}
+
+	return ret;
+}
diff --git a/mt_wifi/embedded/include/iopsys_ioctl.h b/mt_wifi/embedded/include/iopsys_ioctl.h
new file mode 100644
index 0000000..cc7c938
--- /dev/null
+++ b/mt_wifi/embedded/include/iopsys_ioctl.h
@@ -0,0 +1,204 @@
+#ifndef IOPSYS_IOCTL_H
+#define IOPSYS_IOCTL_H
+
+#ifndef OID_IOPSYS_WIFI_FIRST
+#define OID_IOPSYS_WIFI_FIRST		0x8f0
+#endif
+
+#ifndef OID_IOPSYS_WIFI_LAST
+#define OID_IOPSYS_WIFI_LAST		0x8ff
+#endif
+
+/* Iopsys OIDs */
+#define OID_IOPSYS_WIFI_STA_INFO	OID_IOPSYS_WIFI_FIRST + 1
+#define OID_IOPSYS_WIFI_BSS_INFO	OID_IOPSYS_WIFI_FIRST + 2
+#define OID_IOPSYS_WIFI_SITESURVEY	OID_IOPSYS_WIFI_FIRST + 3
+#ifdef ASSOC_CONTROL
+#define OID_IOPSYS_WIFI_ASSOC_CTRL	OID_IOPSYS_WIFI_FIRST + 4
+#endif /* ASSOC_CONTROL */
+#define OID_IOPSYS_WIFI_VENDOR_IE	OID_IOPSYS_WIFI_FIRST + 5
+#define OID_IOPSYS_WIFI_MONITOR_STA	OID_IOPSYS_WIFI_FIRST + 6
+#define OID_IOPSYS_WIFI_BSS_STATS	OID_IOPSYS_WIFI_FIRST + 7
+
+/* wireless modes */
+enum {
+	MODE_B  = 1 << 0,
+	MODE_G  = 1 << 1,
+	MODE_A  = 1 << 2,
+	MODE_N  = 1 << 3,
+	MODE_AC = 1 << 4,
+	MODE_MAX = 5,
+	MODE_UNKNOWN = 1 << MODE_MAX,
+};
+
+/* wireless phytype */
+enum phytype {
+	PHY_DSSS   = 2,
+	PHY_OFDM   = 4,
+	PHY_HRDSSS = 5,
+	PHY_ERP    = 6,
+	PHY_HT     = 7,
+	PHY_DMG    = 8,
+	PHY_VHT    = 9,
+	PHY_MAX    = PHY_VHT,
+};
+
+/* authentication types */
+enum {
+	AUTH_OPEN    = 1<<0,
+	AUTH_SHARED  = 1<<1,
+	AUTH_WEPAUTO = 1<<2,
+	AUTH_WPANONE = 1<<3,
+	AUTH_WPA     = 1<<4,
+	AUTH_WPAPSK  = 1<<5,
+	AUTH_WPA2    = 1<<6,
+	AUTH_WPA2PSK = 1<<7,
+	AUTH_MAX = 8,
+	AUTH_UNKNOWN = 1 << AUTH_MAX,
+};
+
+/* encryption types */
+enum {
+	WIFI_CIPHER_NONE    = 1<<0,
+	WIFI_CIPHER_WEP     = 1<<1,
+	WIFI_CIPHER_TKIP    = 1<<2,
+	WIFI_CIPHER_AES     = 1<<3,
+	WIFI_CIPHER_CCMP256 = 1<<4,
+	WIFI_CIPHER_GCMP128 = 1<<5,
+	WIFI_CIPHER_GCMP256 = 1<<6,
+	WIFI_CIPHER_MAX = 7,
+	WIFI_CIPHER_UNKNOWN = 1 << WIFI_CIPHER_MAX,
+};
+
+/* STA capability/operation flags */
+enum {
+	STA_CAP_WME   = 1<<0,
+	STA_CAP_AMSDU = 1<<1,
+	STA_CAP_AMPDU = 1<<2,
+	STA_CAP_HT    = 1<<3,
+	STA_CAP_VHT   = 1<<4,
+	STA_CAP_PS    = 1<<5,
+	STA_CAP_STBC  = 1<<6,
+	STA_CAP_LDPC  = 1<<7,
+	STA_CAP_BFR   = 1<<8,
+	STA_CAP_BFE   = 1<<9,
+	STA_CAP_SGI   = 1<<10,
+	STA_CAP_VHT_160 = 1<<11,
+	/* ... */
+	STA_CAP_11K_BCN_PASV  = 1<<16,
+	STA_CAP_11K_BCN_ACTV  = 1<<17,
+	STA_CAP_11K_BCN_TBL   = 1<<18,
+	/* ... */
+	STA_CAP_11V_BSS_TRANS = 1<<24,
+};
+
+/** struct wifi_sta_stats - STA stats */
+struct wifi_sta_stats {
+	__u32 tx_pkts;
+	__u32 rx_pkts;
+	__u64 tx_bytes;
+	__u64 rx_bytes;
+	__u32 tx_fail_pkts;
+	__u32 rx_fail_pkts;
+	__u32 tx_retry_pkts;
+	__u32 tx_drop_pkts;
+	__u32 rx_drop_pkts;
+};
+
+struct wifi_rate {
+	__u8 mcs;
+	__u8 bw;
+	__u8 nss;
+	__u8 sgi;
+};
+
+/** struct wifi_sta - STA structure */
+struct wifi_sta {
+	__u8 addr[6];
+	__u32 caps;             /** current operational capability */
+	__u32 maxcaps;          /** max supported capability */
+	__u32 connected_ms;     /** connection time in msecs */
+	__u32 idle_ms;          /** no data idle time in msecs */
+	__u64 airtime_ms;       /** airtime consumed in the last second */
+	__u64 total_airtime_ms; /** total airtime in msecs */
+	struct wifi_rate tx, rx;
+	__u32 tx_rate;          /** rate in mbps */
+	__u32 rx_rate;
+	__u32 maxrate;          /** max phy rate in mbps */
+	__s32 rssi[4];
+	struct wifi_sta_stats stats;
+} __attribute__((packed));
+
+/** struct wifi_bssload - BSS load */
+struct wifi_bssload {
+	__u32 sta_count;         /** number of STAs connected */
+	__u32 utilization;       /** channel utilization [0..255] */
+	__u32 available;         /** available admission capacity */
+} __attribute__((packed));
+
+/** struct bss - BSS info from scan results */
+struct wifi_bss {
+	__u32 channel;
+	__u32 frequency;
+	char ssid[33];
+	char bssid[18];       /* aa:bb:cc:xx:yy:zz format */
+	__u32 encryption;
+	__u32 cipher;
+	__s32 rssi;
+	__s32 snr;
+	__u32 mode;
+	struct wifi_bssload load;
+} __attribute__((packed));
+
+/*
+ * struct wifi_ap_stats - per-BSS statistics
+ */
+struct wifi_ap_stats {
+	unsigned long tx_bytes;
+	unsigned long rx_bytes;
+	unsigned long tx_pkts;
+	unsigned long rx_pkts;
+	__u32 tx_err_pkts;
+	__u32 tx_rtx_pkts;
+	__u32 tx_rtx_fail_pkts;
+	__u32 tx_retry_pkts;
+	__u32 tx_mretry_pkts;
+	__u32 ack_fail_pkts;
+	__u32 aggr_pkts;
+	__u32 rx_err_pkts;
+	unsigned long tx_ucast_pkts;
+	unsigned long rx_ucast_pkts;
+	__u32 tx_dropped_pkts;
+	__u32 rx_dropped_pkts;
+	unsigned long tx_mcast_pkts;
+	unsigned long rx_mcast_pkts;
+	unsigned long tx_bcast_pkts;
+	unsigned long rx_bcast_pkts;
+	unsigned long rx_unknown_pkts;
+};
+
+/* vendor ie struct */
+struct wifi_vendor_ie {
+	struct {
+		__u8 eid;
+		__u8 len;
+	} ie_hdr;
+	__u8 oui[3];
+	__u8 data[];
+} __attribute__ ((packed));
+
+/* vendor ie request struct */
+struct vendor_iereq {
+	__u32 mask;
+	struct wifi_vendor_ie ie;
+};
+
+
+extern int mt_ioctl_iopsys(RTMP_ADAPTER *pAd, RTMP_IOCTL_INPUT_STRUCT *wrq, int cmd);
+extern void update_airtime_periodic(RTMP_ADAPTER *pAd);
+
+extern int mt_update_vendor_ie(RTMP_ADAPTER *pAd, struct wifi_dev *wdev,
+					u8 *frm, ULONG frm_len);
+
+extern void do_monitor_sta(BSS_STRUCT *bss, u8 *sta, char rssi[]);
+#endif /* IOPSYS_IOCTL_H */
diff --git a/mt_wifi/embedded/include/rt_config.h b/mt_wifi/embedded/include/rt_config.h
index c91defc..9a12960 100644
--- a/mt_wifi/embedded/include/rt_config.h
+++ b/mt_wifi/embedded/include/rt_config.h
@@ -393,4 +393,9 @@
 
 #include "misc_app.h"
 
+
+#if defined(CONFIG_AP_SUPPORT)
+#include "iopsys_ioctl.h"
+#endif
+
 #endif	/* __RT_CONFIG_H__ */
diff --git a/mt_wifi_ap/Makefile b/mt_wifi_ap/Makefile
index f8f16ab..b179e9d 100644
--- a/mt_wifi_ap/Makefile
+++ b/mt_wifi_ap/Makefile
@@ -633,6 +633,12 @@ ap_objs := $(SRC_EMBEDDED_DIR)/ap/ap.o\
             $(SRC_EMBEDDED_DIR)/ap/ap_vow.o\
             $(SRC_DIR)/os/linux/ap_ioctl.o
 
+# IOPSYS
+ap_objs += $(SRC_EMBEDDED_DIR)/ap/iopsys_ioctl.o
+EXTRA_CFLAGS += -DASSOC_CONTROL
+EXTRA_CFLAGS += -DIOPSYS_MONITOR_STA
+
+
 ifeq ($(CONFIG_MBSS_SUPPORT),y)
     EXTRA_CFLAGS += -DMBSS_SUPPORT
 
-- 
2.7.4

